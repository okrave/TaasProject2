package com.example.togroup5.demo.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;

@Configuration
@EnableWebSecurity
public class ServerSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private AccessDeniedHandler accessDeniedHandler;

    /**
     * Utilizzata dall'implementazione di default di authenticationManager() per ottenere un
     * AuthenticationManager, In-Memory is the easiest way to implement authentication in Spring Security,
     * but it doesn't really have any value outside of experiments, prototypes or maybe testing.
     * Production systems usually rely either on a database, an LDAP server or any other specific resource to store the users information.
     * <p>
     * In-memory authentication is the simplest form, and requires that the credentials for all users be specified in the code itself. This is impractical in all but the simplest cases.
     * <p>
     * In JDBC based authentication user’s authentication and authorization information are stored in database
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        /*
         * Non stiamo altro che creando gli utenti che possono accedere ai contenuti web. passwordEncoder lo utilizziamo per criptare la password
         * In caso usassimo il database allora dovremmo ricordarci di criptare prima di salvare
         *
         * */
        auth.inMemoryAuthentication()
                .withUser("user").password(passwordEncoder().encode("password")).roles("USER")
                .and()
                .withUser("user1").password(passwordEncoder().encode("password")).roles("USER")
                .and()
                .withUser("admin").password(passwordEncoder().encode("password")).roles("ADMIN");
    }


    /*In questa configurazione definiamo quali user e quali ruoli possono accedere alle pagine
     * in antMatcher() l'ordine è importante dovremmo specificare i più generali prima*/
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        /*http.csrf().disable() //Disabilita il controllo contro attacchi csrf
                .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .antMatchers("/anonymous*").anonymous()
                .antMatchers("/login*").permitAll()
                .anyRequest().authenticated(); // Per qualsiasi altra pagina è richiesta l'autenticazione
                .and()
                .formLogin() // corrisponde al login
                .loginPage("/login.html").permitAll() // Se non lo specifichiamo spring ci dara una pagina di login fatta da lui stesso
                    .loginProcessingUrl("/perform_login") //The default URL where the Spring Login will POST to trigger the authentication process is /login which used to be /j_spring_security_check
                    .defaultSuccessUrl("/index.html",true) //After a successful Login process, the user is redirected to a page – which by default is the root of the web application.
                    .failureUrl("/index.html?error=true") //Same as with the Login Page, the Login Failure Page is autogenerated by Spring Security at /login?error by default.
                .and() //finisce il login
                .logout().permitAll()
                .logoutUrl("/perform_logout")
                .deleteCookies("JSESSIONID")
                .logoutSuccessHandler(logoutSuccessHandler());*/
        http
                .authorizeRequests()
                    .antMatchers(
                        "/js/**",
                        "/css/**",
                        "/img/**",
                        "/webjars/**").permitAll()
                    .antMatchers("/", "/home","/login").permitAll()
                    .antMatchers("/admin").hasAnyRole("ADMIN")
                    .antMatchers("/user/**").hasAnyRole("USER")
                    .anyRequest().authenticated()
                    .and()
                .formLogin()
                    .loginPage("/login")
                    //.failureUrl("/login-error").permitAll()
                    .and()
                .logout()
                    .invalidateHttpSession(true)
                    .clearAuthentication(true)
                    .permitAll()
                .and()
                .exceptionHandling().accessDeniedHandler(accessDeniedHandler);

    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
